# Scalable Machine Learning and Deep Learning Lab 2

## Fine tuning a large-language model - Lab 2

## Task 2
The assignments in this task are to describe how to improve model performance using (1) a model-centric approach and (2) a data-centric approach. Such an improvement must be shown using any of the approaches by fine-tuning and imported to a UI for inference.


## Improving Performance
Model-centric approaches include for example hyperparameter tuning, and base model choice. While a smaller model could be less capable, a larger model could be strong enough to gain an improvement in performance as it is more capable. Hyperparameter tuning and optimization, including learning rate scheduling, weight decay and gradient clipping, are methods that can be applied to optimize the performance of the model.

A model centric approach that we used in this lab was to decrease the size of the model, in order to increase the number of training steps we could do within a reasonable timeframe. Llama with 3B parameters took a very long time to finetune, and we were able to finetune the smaller llama model (1B) for double the steps within a smaller timeframe. The thought process here is that more steps on a smaller model can outperform less steps on a larger model. 

Data-centric approaches include for example finding new data sources, or data preprocessing. Duplicates could lead to contamination between training and validation / test splits, and it could be that better data sources exist. Also, we believe that the data should represent the diversity of instructions users could come with. For example, instructions of different length. 

## Results
The first model we used was ```LLama-3.2-3B-Instruct``` while our second model was ```LLama-3.2-1B-Instruct-bnb-4bit```.  Our analysis of the model performances are based on our perception of what the better output is given the prompt. Below are the input prompts, the output of each model and their time taken, and an average for both models.

| Input Prompt | 3B Output | 3B Time | 1B Output | 1B Time |  
| --- | --- | --- | --- | --- |  
| What is 5 + 6? | The answer to 5 + 6 is 11. | 46 seconds | The answer to 5 + 6 is 11. | 14 seconds |
| How many ‘r’s are in the word ‘strawberry’? | There are 3 'r's in the word'strawberry'. | 11 seconds | There are 3 'r's in the word'strawberry'. | 5 seconds |
| Explain why the word ‘strawberry’ doesn’t have 2 ‘r’s. | The word'strawberry' doesn't have 2 'r's because it actually has 3 'r's. The sequence of letters in the word is S-T-R-A-W-B-E-R-R-Y, and the 'r's are located in the middle of the word. | 109 seconds | The word'strawberry' doesn't have 2 'r's because it is spelled with a single 'r'. The 'r' in'strawberry' is part of the word's spelling, not repeated. | 14 seconds |
| Explain the difference between positive and negative numbers in max five sentences. | Positive numbers are those that are greater than zero, while negative numbers are those that are less than zero. Positive numbers are often represented by a plus sign (+) or a number greater than zero, while negative numbers are represented by a minus sign (-) or a number less than zero. For example, 5 is a positive number, while -3 is a negative number. The difference between positive and negative numbers is that positive numbers are considered "good" or "positive" while negative numbers are considered "bad" or "negative". | 97 seconds | Positive numbers are those that are greater than zero, such as 5, 10, and 15. Negative numbers, on the other hand, are those that are less than zero, like -5, -10, and -15. The key difference between the two is the sign, with positive numbers having a "+" sign and negative numbers having a "-" sign. Additionally, the magnitude of the number also differs, with positive numbers having a larger absolute value than negative numbers. | 47 seconds |
| Explain the yield keyword in Python without showing code in max five sentences. | The yield keyword in Python is used to define a generator function. It allows the function to produce a sequence of values instead of computing them all at once and returning them in a list or tuple. When the function is called, it starts executing until it reaches the first yield statement. At this point, the function returns the value specified by the yield statement and pauses its execution. The function can then be resumed from where it left off, continuing to execute until it reaches the next yield statement. | 187 seconds | The yield keyword in Python is used to define a generator function. It allows the function to produce a sequence of values on the fly, rather than storing them all in memory at once. This can be useful when dealing with large datasets or when working with data that doesn't fit into memory. The yield statement returns the next value in the sequence, and the function continues to the next yield statement until there are no more values to return. | 64 seconds |
| Explain why 1 + 1 can never become negative. | The reason 1 + 1 can never become negative is due to the fundamental properties of arithmetic operations. In basic arithmetic, addition is defined as combining two or more numbers to get a total or a sum. When you add two positive numbers, the result is always positive.<br><br>In the case of 1 + 1, both numbers are positive (1), so when you add them together, the result will also be positive. This is because the sum of two positive numbers is always greater than or equal to zero, and never less than zero.<br><br>In contrast, if you were to subtract 1 from 1, the result would be 0, which is a neutral number. However, if you were to subtract 1 from a negative number, the result would be a negative number. For example, if you subtracted 1 from -1, the result would be -2, which is a negative number.<br><br>Therefore, the arithmetic operation of addition, when applied to positive numbers, always results in a positive number. This is why 1 + 1 can never become negative. | 160 seconds | The reason 1 + 1 can never become negative is due to the fundamental properties of addition and subtraction in mathematics.<br><br>When you add two numbers, you are combining them to get a new number. The result of this operation is always a positive number, because you are always adding two positive quantities together.<br><br>For example, 1 + 1 = 2, which is a positive number. If you subtract 1 from 2, you get 1, which is also a positive number.<br><br>On the other hand, if you subtract 1 from 2, you get -1, which is a negative number. This is because you are subtracting a positive quantity from a positive quantity, which results in a negative number.<br><br>Therefore, the only way to get a negative number is to subtract a positive number from a positive number. This is why 1 + 1 can never become negative. | 47 seconds |
| How do astronomers measure the Doppler Effect? Please explain this in max five sentences. | Astronomers measure the Doppler Effect by observing the shift in the wavelength of light emitted by celestial objects. When an object is moving towards the observer, the light waves are compressed, resulting in a shorter wavelength. Conversely, when an object is moving away from the observer, the light waves are stretched, resulting in a longer wavelength. By comparing the observed wavelengths with the known wavelengths of the object, astronomers can determine the velocity of the object. This technique is commonly used to study the motion of stars, galaxies, and other celestial bodies. | 61 seconds | Astronomers measure the Doppler Effect by observing the shift in the wavelength of light emitted or absorbed by celestial objects. This shift is caused by the relative motion between the object and the observer, resulting in a change in the object's spectral lines. By analyzing the shift in the spectral lines, astronomers can determine the velocity of the object relative to the observer. This information can be used to calculate the object's distance from Earth, as well as its motion through space. | 25 seconds |
| Change the following email content to be more formal “yo everyone, meeting delayed by 1 hour hahah c u then”. | Subject: Update on Meeting Time<br><br>Dear All,<br><br>I am writing to inform you that the meeting has been delayed by one hour. I apologize for any inconvenience this may cause and appreciate your understanding in this matter.<br><br>The meeting will now take place at [insert new time]. I look forward to seeing you all there.<br><br>Best regards,<br><br>[Your Name]. | 54 seconds | Here's a more formal version of the email content:<br><br>Subject: Rescheduling of Meeting<br><br>Dear Team,<br><br>I am writing to inform you that our meeting has been rescheduled to take place one hour later. We will be meeting at 2:00 PM instead of the previously scheduled time.<br><br>Please make sure to arrive at the meeting location on time. If you have any questions or concerns, please do not hesitate to reach out to me.<br><br>Thank you for your understanding and cooperation.<br><br>Best regards,<br><br>[Your Name] | 21 seconds |
| What is the difference between Python and Java, in max five sentences? | Python and Java are both high-level programming languages, but they have different syntax and structure. Python is known for its simplicity and readability, while Java is more complex and has a steeper learning curve. Python is often used for web development, data analysis, and machine learning, while Java is commonly used for Android app development, web development, and enterprise software. Overall, Python is generally easier to learn and use, while Java is more versatile and widely used. | 51 seconds | Python and Java are two popular programming languages used for different purposes. Python is a high-level, interpreted language that is often used for rapid prototyping, data analysis, and web development. Java, on the other hand, is a statically-typed, compiled language that is commonly used for building large-scale applications, Android apps, and enterprise software. Python is generally easier to learn and use, while Java requires more knowledge of object-oriented programming concepts. | 20 seconds |
|Why do people always use Will Smith eating spaghetti as a benchmark for video generation models? Answer within five sentences. | The use of Will Smith eating spaghetti as a benchmark for video generation models is likely due to its simplicity and recognizability. The image is easily identifiable and can be used to test the model's ability to generate realistic and coherent video content. Additionally, the image is not too complex or detailed, making it a good test case for models that are still learning to generate videos. The use of this image as a benchmark also reflects the model's ability to generate videos that are both realistic and engaging. Overall, the image of Will Smith eating spaghetti serves as a useful test case for video generation models. | 66 seconds | The use of Will Smith eating spaghetti as a benchmark for video generation models is largely due to the fact that it is a simple and easily observable task. The model's ability to generate a coherent and visually appealing video based on a specific input (Will Smith eating spaghetti) is a good indicator of its overall performance. Additionally, the model's output is relatively easy to analyze and compare to other models, making it a useful benchmark for evaluating their capabilities. The use of spaghetti as a benchmark is also a nod to the classic "Will Smith eats spaghetti" meme, which has become a cultural reference point for evaluating the performance of AI models. | 31 seconds |

Average time for 3B: 78 seconds  
Average time for 1B: 29 seconds

## LLM that works best with the UI for inference

We trained two models, namely ```Llama-3.2-3B-Instruct``` and ```Llama-3.2-1B-Instruct-bnb-4bit```. The large model was rather slow during inference, and some prompts took up to 180 seconds. That is not very useful for a user. As can be seen above, the average inference time for the large model is 78 seconds, and 29 seconds for the smaller model. If we only look at the inference time as a metric to find the model that works best with the UI for inference, the smaller model outperforms the larger model.  
  
Another observation is that the smaller model seems to be more suitable from an inference perspective time-wise, but the outputs seem to have less accuracy compared to the larger model.
